
import { AptosParserRepo, getTypeTagFullname, StructTag, parseTypeTagOrThrow, u8, u64, u128, print, strToU8, u8str, DummyCache, ActualStringClass, sendPayloadTx } from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Cetus_amm from './cetus_amm';

export const readConfig = (program: Command) => {
  const {config, profile} = program.opts();
  const ymlContent = fs.readFileSync(config, {encoding: "utf-8"});
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return {client, account};
}

const program = new Command();

program
  .name('yarn cli')
  .description('Move TS CLI generated by move-to-ts')
  .requiredOption('-c, --config <path>', 'path to your aptos config.yml (generated with "aptos init")')
  .option('-p, --profile <PROFILE>', 'aptos config profile to use', 'default')


const amm_script_add_liquidity = async (CoinTypeA: string, CoinTypeB: string, amount_a_desired: string, amount_b_desired: string, amount_a_min: string, amount_b_min: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const amount_a_desired_ = u128(amount_a_desired);
  const amount_b_desired_ = u128(amount_b_desired);
  const amount_a_min_ = u128(amount_a_min);
  const amount_b_min_ = u128(amount_b_min);
  const payload = Cetus_amm.Amm_script.buildPayload_add_liquidity(amount_a_desired_, amount_b_desired_, amount_a_min_, amount_b_min_, [CoinTypeA_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:add-liquidity")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<amount_a_desired>')
  .argument('<amount_b_desired>')
  .argument('<amount_a_min>')
  .argument('<amount_b_min>')
  .action(amm_script_add_liquidity);


const amm_script_init_pool = async (CoinTypeA: string, CoinTypeB: string, protocol_fee_to: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const protocol_fee_to_ = new HexString(protocol_fee_to);
  const payload = Cetus_amm.Amm_script.buildPayload_init_pool(protocol_fee_to_, [CoinTypeA_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:init-pool")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<protocol_fee_to>')
  .action(amm_script_init_pool);


const amm_script_remove_liquidity = async (CoinTypeA: string, CoinTypeB: string, liquidity: string, amount_a_min: string, amount_b_min: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const liquidity_ = u128(liquidity);
  const amount_a_min_ = u128(amount_a_min);
  const amount_b_min_ = u128(amount_b_min);
  const payload = Cetus_amm.Amm_script.buildPayload_remove_liquidity(liquidity_, amount_a_min_, amount_b_min_, [CoinTypeA_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:remove-liquidity")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<liquidity>')
  .argument('<amount_a_min>')
  .argument('<amount_b_min>')
  .action(amm_script_remove_liquidity);


const amm_script_set_pause_status = async (pause: string) => {
  const {client, account} = readConfig(program);
  const pause_ = pause=='true';
  const payload = Cetus_amm.Amm_script.buildPayload_set_pause_status(pause_);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:set-pause-status")
  .description("")
  .argument('<pause>')
  .action(amm_script_set_pause_status);


const amm_script_set_pool_fee_config = async (trade_fee_numerator: string, trade_fee_denominator: string, protocol_fee_numerator: string, protocol_fee_denominator: string) => {
  const {client, account} = readConfig(program);
  const trade_fee_numerator_ = u64(trade_fee_numerator);
  const trade_fee_denominator_ = u64(trade_fee_denominator);
  const protocol_fee_numerator_ = u64(protocol_fee_numerator);
  const protocol_fee_denominator_ = u64(protocol_fee_denominator);
  const payload = Cetus_amm.Amm_script.buildPayload_set_pool_fee_config(trade_fee_numerator_, trade_fee_denominator_, protocol_fee_numerator_, protocol_fee_denominator_);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:set-pool-fee-config")
  .description("")
  .argument('<trade_fee_numerator>')
  .argument('<trade_fee_denominator>')
  .argument('<protocol_fee_numerator>')
  .argument('<protocol_fee_denominator>')
  .action(amm_script_set_pool_fee_config);


const amm_script_swap_coin_for_exact_coin = async (CoinTypeA: string, CoinTypeB: string, amount_a_in_max: string, amount_b_out: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const amount_a_in_max_ = u128(amount_a_in_max);
  const amount_b_out_ = u128(amount_b_out);
  const payload = Cetus_amm.Amm_script.buildPayload_swap_coin_for_exact_coin(amount_a_in_max_, amount_b_out_, [CoinTypeA_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:swap-coin-for-exact-coin")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<amount_a_in_max>')
  .argument('<amount_b_out>')
  .action(amm_script_swap_coin_for_exact_coin);


const amm_script_swap_coin_for_exact_coin_router2 = async (CoinTypeA: string, CoinTypeX: string, CoinTypeB: string, amount_a_in_max: string, amount_b_out: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeX_ = parseTypeTagOrThrow(CoinTypeX);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const amount_a_in_max_ = u128(amount_a_in_max);
  const amount_b_out_ = u128(amount_b_out);
  const payload = Cetus_amm.Amm_script.buildPayload_swap_coin_for_exact_coin_router2(amount_a_in_max_, amount_b_out_, [CoinTypeA_, CoinTypeX_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:swap-coin-for-exact-coin-router2")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeX>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<amount_a_in_max>')
  .argument('<amount_b_out>')
  .action(amm_script_swap_coin_for_exact_coin_router2);


const amm_script_swap_coin_for_exact_coin_router3 = async (CoinTypeA: string, CoinTypeX: string, CoinTypeY: string, CoinTypeB: string, amount_a_in_max: string, amount_b_out: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeX_ = parseTypeTagOrThrow(CoinTypeX);
  const CoinTypeY_ = parseTypeTagOrThrow(CoinTypeY);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const amount_a_in_max_ = u128(amount_a_in_max);
  const amount_b_out_ = u128(amount_b_out);
  const payload = Cetus_amm.Amm_script.buildPayload_swap_coin_for_exact_coin_router3(amount_a_in_max_, amount_b_out_, [CoinTypeA_, CoinTypeX_, CoinTypeY_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:swap-coin-for-exact-coin-router3")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeX>')
  .argument('<TYPE_CoinTypeY>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<amount_a_in_max>')
  .argument('<amount_b_out>')
  .action(amm_script_swap_coin_for_exact_coin_router3);


const amm_script_swap_exact_coin_for_coin = async (CoinTypeA: string, CoinTypeB: string, amount_a_in: string, amount_b_out_min: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const amount_a_in_ = u128(amount_a_in);
  const amount_b_out_min_ = u128(amount_b_out_min);
  const payload = Cetus_amm.Amm_script.buildPayload_swap_exact_coin_for_coin(amount_a_in_, amount_b_out_min_, [CoinTypeA_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:swap-exact-coin-for-coin")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<amount_a_in>')
  .argument('<amount_b_out_min>')
  .action(amm_script_swap_exact_coin_for_coin);


const amm_script_swap_exact_coin_for_coin_router2 = async (CoinTypeA: string, CoinTypeX: string, CoinTypeB: string, amount_a_in: string, amount_b_out_min: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeX_ = parseTypeTagOrThrow(CoinTypeX);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const amount_a_in_ = u128(amount_a_in);
  const amount_b_out_min_ = u128(amount_b_out_min);
  const payload = Cetus_amm.Amm_script.buildPayload_swap_exact_coin_for_coin_router2(amount_a_in_, amount_b_out_min_, [CoinTypeA_, CoinTypeX_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:swap-exact-coin-for-coin-router2")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeX>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<amount_a_in>')
  .argument('<amount_b_out_min>')
  .action(amm_script_swap_exact_coin_for_coin_router2);


const amm_script_swap_exact_coin_for_coin_router3 = async (CoinTypeA: string, CoinTypeX: string, CoinTypeY: string, CoinTypeB: string, amount_a_in: string, amount_b_out_min: string) => {
  const {client, account} = readConfig(program);
  const CoinTypeA_ = parseTypeTagOrThrow(CoinTypeA);
  const CoinTypeX_ = parseTypeTagOrThrow(CoinTypeX);
  const CoinTypeY_ = parseTypeTagOrThrow(CoinTypeY);
  const CoinTypeB_ = parseTypeTagOrThrow(CoinTypeB);
  const amount_a_in_ = u128(amount_a_in);
  const amount_b_out_min_ = u128(amount_b_out_min);
  const payload = Cetus_amm.Amm_script.buildPayload_swap_exact_coin_for_coin_router3(amount_a_in_, amount_b_out_min_, [CoinTypeA_, CoinTypeX_, CoinTypeY_, CoinTypeB_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("amm-script:swap-exact-coin-for-coin-router3")
  .description("")
  .argument('<TYPE_CoinTypeA>')
  .argument('<TYPE_CoinTypeX>')
  .argument('<TYPE_CoinTypeY>')
  .argument('<TYPE_CoinTypeB>')
  .argument('<amount_a_in>')
  .argument('<amount_b_out_min>')
  .action(amm_script_swap_exact_coin_for_coin_router3);




program.parse();
